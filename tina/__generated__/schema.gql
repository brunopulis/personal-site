# DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
"""References another document, used as a foreign key"""
scalar Reference

""""""
scalar JSON

type SystemInfo {
  filename: String!
  title: String
  basename: String!
  hasReferences: Boolean
  breadcrumbs(excludeExtension: Boolean): [String!]!
  path: String!
  relativePath: String!
  extension: String!
  template: String!
  collection: Collection!
}

type Folder {
  name: String!
  path: String!
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

""""""
interface Node {
  id: ID!
}

""""""
interface Document {
  id: ID!
  _sys: SystemInfo
  _values: JSON!
}

"""A relay-compliant pagination connection"""
interface Connection {
  totalCount: Float!
  pageInfo: PageInfo!
}

type Query {
  getOptimizedQuery(queryString: String!): String
  collection(collection: String): Collection!
  collections: [Collection!]!
  node(id: String): Node!
  document(collection: String, relativePath: String): DocumentNode!
  post(relativePath: String): Post!
  postConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: PostFilter): PostConnection!
  note(relativePath: String): Note!
  noteConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: NoteFilter): NoteConnection!
  blogroll(relativePath: String): Blogroll!
  blogrollConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: BlogrollFilter): BlogrollConnection!
  book(relativePath: String): Book!
  bookConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: BookFilter): BookConnection!
  movie(relativePath: String): Movie!
  movieConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: MovieFilter): MovieConnection!
  newsletter(relativePath: String): Newsletter!
  newsletterConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: NewsletterFilter): NewsletterConnection!
  speaking(relativePath: String): Speaking!
  speakingConnection(before: String, after: String, first: Float, last: Float, sort: String, filter: SpeakingFilter): SpeakingConnection!
}

input DocumentFilter {
  post: PostFilter
  note: NoteFilter
  blogroll: BlogrollFilter
  book: BookFilter
  movie: MovieFilter
  newsletter: NewsletterFilter
  speaking: SpeakingFilter
}

type DocumentConnectionEdges {
  cursor: String!
  node: DocumentNode
}

type DocumentConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [DocumentConnectionEdges]
}

type Collection {
  name: String!
  slug: String!
  label: String
  path: String!
  format: String
  matches: String
  templates: [JSON]
  fields: [JSON]
  documents(before: String, after: String, first: Float, last: Float, sort: String, filter: DocumentFilter, folder: String): DocumentConnection!
}

union DocumentNode = Post | Note | Blogroll | Book | Movie | Newsletter | Speaking | Folder

type PostSeo {
  meta_title: String
  meta_description: String
  keywords: [String]
}

type Post implements Node & Document {
  title: String!
  publishDate: String!
  author: String!
  description: String!
  featured_image: String
  body: JSON!
  categories: [String]
  tags: [String]
  draft: Boolean
  seo: PostSeo
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input StringFilter {
  startsWith: String
  eq: String
  exists: Boolean
  in: [String]
}

input DatetimeFilter {
  after: String
  before: String
  eq: String
  exists: Boolean
  in: [String]
}

input ImageFilter {
  startsWith: String
  eq: String
  exists: Boolean
  in: [String]
}

input RichTextFilter {
  startsWith: String
  eq: String
  exists: Boolean
}

input BooleanFilter {
  eq: Boolean
  exists: Boolean
}

input PostSeoFilter {
  meta_title: StringFilter
  meta_description: StringFilter
  keywords: StringFilter
}

input PostFilter {
  title: StringFilter
  publishDate: DatetimeFilter
  author: StringFilter
  description: StringFilter
  featured_image: ImageFilter
  body: RichTextFilter
  categories: StringFilter
  tags: StringFilter
  draft: BooleanFilter
  seo: PostSeoFilter
}

type PostConnectionEdges {
  cursor: String!
  node: Post
}

type PostConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [PostConnectionEdges]
}

type Note implements Node & Document {
  title: String!
  publishDate: String!
  description: String!
  featured_image: String
  body: JSON!
  categories: [String]
  tags: [String]
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input NoteFilter {
  title: StringFilter
  publishDate: DatetimeFilter
  description: StringFilter
  featured_image: ImageFilter
  body: RichTextFilter
  categories: StringFilter
  tags: StringFilter
}

type NoteConnectionEdges {
  cursor: String!
  node: Note
}

type NoteConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [NoteConnectionEdges]
}

type Blogroll implements Node & Document {
  title: String!
  url: String!
  description: String
  category: String!
  rss_feed: String
  date_added: String
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input BlogrollFilter {
  title: StringFilter
  url: StringFilter
  description: StringFilter
  category: StringFilter
  rss_feed: StringFilter
  date_added: DatetimeFilter
}

type BlogrollConnectionEdges {
  cursor: String!
  node: Blogroll
}

type BlogrollConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [BlogrollConnectionEdges]
}

type Book implements Node & Document {
  title: String!
  description: String
  author: String!
  publishDate: String!
  body: JSON
  category: [String!]!
  cover: String
  rating: String
  status: [String!]!
  reading_date: String
  pages: Float
  recommended_for: String
  purchase_link: String
  tags: [String]
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input NumberFilter {
  lt: Float
  lte: Float
  gte: Float
  gt: Float
  eq: Float
  exists: Boolean
  in: [Float]
}

input BookFilter {
  title: StringFilter
  description: StringFilter
  author: StringFilter
  publishDate: DatetimeFilter
  body: RichTextFilter
  category: StringFilter
  cover: ImageFilter
  rating: StringFilter
  status: StringFilter
  reading_date: DatetimeFilter
  pages: NumberFilter
  recommended_for: StringFilter
  purchase_link: StringFilter
  tags: StringFilter
}

type BookConnectionEdges {
  cursor: String!
  node: Book
}

type BookConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [BookConnectionEdges]
}

type Movie implements Node & Document {
  title: String!
  body: JSON
  genres: [String!]!
  poster: String
  rating: String
  status: String!
  watched_date: String
  favorite: Boolean
  streaming: [String]
  tags: [String]
  notes: String
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input MovieFilter {
  title: StringFilter
  body: RichTextFilter
  genres: StringFilter
  poster: ImageFilter
  rating: StringFilter
  status: StringFilter
  watched_date: DatetimeFilter
  favorite: BooleanFilter
  streaming: StringFilter
  tags: StringFilter
  notes: StringFilter
}

type MovieConnectionEdges {
  cursor: String!
  node: Movie
}

type MovieConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [MovieConnectionEdges]
}

type Newsletter implements Node & Document {
  title: String!
  issue: String!
  coverImage: String
  body: JSON
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input NewsletterFilter {
  title: StringFilter
  issue: StringFilter
  coverImage: ImageFilter
  body: RichTextFilter
}

type NewsletterConnectionEdges {
  cursor: String!
  node: Newsletter
}

type NewsletterConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [NewsletterConnectionEdges]
}

type Speaking implements Node & Document {
  title: String!
  issue: String!
  coverImage: String
  body: JSON
  id: ID!
  _sys: SystemInfo!
  _values: JSON!
}

input SpeakingFilter {
  title: StringFilter
  issue: StringFilter
  coverImage: ImageFilter
  body: RichTextFilter
}

type SpeakingConnectionEdges {
  cursor: String!
  node: Speaking
}

type SpeakingConnection implements Connection {
  pageInfo: PageInfo!
  totalCount: Float!
  edges: [SpeakingConnectionEdges]
}

type Mutation {
  addPendingDocument(collection: String!, relativePath: String!, template: String): DocumentNode!
  updateDocument(collection: String, relativePath: String!, params: DocumentUpdateMutation!): DocumentNode!
  deleteDocument(collection: String, relativePath: String!): DocumentNode!
  createDocument(collection: String, relativePath: String!, params: DocumentMutation!): DocumentNode!
  createFolder(collection: String, relativePath: String!): DocumentNode!
  updatePost(relativePath: String!, params: PostMutation!): Post!
  createPost(relativePath: String!, params: PostMutation!): Post!
  updateNote(relativePath: String!, params: NoteMutation!): Note!
  createNote(relativePath: String!, params: NoteMutation!): Note!
  updateBlogroll(relativePath: String!, params: BlogrollMutation!): Blogroll!
  createBlogroll(relativePath: String!, params: BlogrollMutation!): Blogroll!
  updateBook(relativePath: String!, params: BookMutation!): Book!
  createBook(relativePath: String!, params: BookMutation!): Book!
  updateMovie(relativePath: String!, params: MovieMutation!): Movie!
  createMovie(relativePath: String!, params: MovieMutation!): Movie!
  updateNewsletter(relativePath: String!, params: NewsletterMutation!): Newsletter!
  createNewsletter(relativePath: String!, params: NewsletterMutation!): Newsletter!
  updateSpeaking(relativePath: String!, params: SpeakingMutation!): Speaking!
  createSpeaking(relativePath: String!, params: SpeakingMutation!): Speaking!
}

input DocumentUpdateMutation {
  post: PostMutation
  note: NoteMutation
  blogroll: BlogrollMutation
  book: BookMutation
  movie: MovieMutation
  newsletter: NewsletterMutation
  speaking: SpeakingMutation
  relativePath: String
}

input DocumentMutation {
  post: PostMutation
  note: NoteMutation
  blogroll: BlogrollMutation
  book: BookMutation
  movie: MovieMutation
  newsletter: NewsletterMutation
  speaking: SpeakingMutation
}

input PostSeoMutation {
  meta_title: String
  meta_description: String
  keywords: [String]
}

input PostMutation {
  title: String
  publishDate: String
  author: String
  description: String
  featured_image: String
  body: JSON
  categories: [String]
  tags: [String]
  draft: Boolean
  seo: PostSeoMutation
}

input NoteMutation {
  title: String
  publishDate: String
  description: String
  featured_image: String
  body: JSON
  categories: [String]
  tags: [String]
}

input BlogrollMutation {
  title: String
  url: String
  description: String
  category: String
  rss_feed: String
  date_added: String
}

input BookMutation {
  title: String
  description: String
  author: String
  publishDate: String
  body: JSON
  category: [String]
  cover: String
  rating: String
  status: [String]
  reading_date: String
  pages: Float
  recommended_for: String
  purchase_link: String
  tags: [String]
}

input MovieMutation {
  title: String
  body: JSON
  genres: [String]
  poster: String
  rating: String
  status: String
  watched_date: String
  favorite: Boolean
  streaming: [String]
  tags: [String]
  notes: String
}

input NewsletterMutation {
  title: String
  issue: String
  coverImage: String
  body: JSON
}

input SpeakingMutation {
  title: String
  issue: String
  coverImage: String
  body: JSON
}

schema {
  query: Query
  mutation: Mutation
}
